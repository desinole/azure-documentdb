using System.Net.Security;
using MongoDB.Bson;
using MongoDB.Driver;

// Connect to DocumentDB gateway
var settings = MongoClientSettings.FromConnectionString("");
settings.SslSettings = new SslSettings
{
    ServerCertificateValidationCallback = (sender, certificate, chain, errors) => true
};
settings.ServerSelectionTimeout = TimeSpan.FromMinutes(5);
var client = new MongoClient(settings);
var db = client.GetDatabase("sampledb");
var collection = db.GetCollection<BsonDocument>("products");

// --- Step 1: Create a DiskANN vector index ---
Console.WriteLine("Creating DiskANN vector index...");

var createIndex = new BsonDocument
{
    { "createIndexes", "products" },
    { "indexes", new BsonArray
        {
            new BsonDocument
            {
                { "name", "vectorIndex" },
                { "key", new BsonDocument("embedding", "cosmosSearch") },
                { "cosmosSearchOptions", new BsonDocument
                    {
                        { "kind", "vector-diskann" },
                        { "dimensions", 3 },
                        { "similarity", "COS" },
                        { "maxDegree", 32 },
                        { "lBuild", 64 }
                    }
                }
            }
        }
    }
};

db.RunCommand<BsonDocument>(createIndex, ReadPreference.Primary);
Console.WriteLine("DiskANN index created.");

// Create a standard index on category for filtered vector search
collection.Indexes.CreateOne(new CreateIndexModel<BsonDocument>(
    Builders<BsonDocument>.IndexKeys.Ascending("category"),
    new CreateIndexOptions { Name = "category_1" }));
Console.WriteLine("Category filter index created.\n");

// --- Step 2: Insert documents with vector embeddings ---
// These are simplified 3-dimensional embeddings for demo purposes.
// In production, embeddings are generated by a model (e.g., Azure OpenAI, Hugging Face)
// and typically have 256–3072 dimensions. Here the 3 dimensions loosely represent:
//   [0] = "tech/computing" affinity  (higher = more tech-related)
//   [1] = "lifestyle/audio" affinity  (higher = more audio/lifestyle-related)
//   [2] = "premium/quality" affinity  (higher = more premium)
// Similar products will have vectors that are close together in this space.
Console.WriteLine("Inserting documents with embeddings...");

var documents = new[]
{
    new BsonDocument
    {
        { "_id", "vec-001" },
        { "name", "Wireless Headphones" },
        { "category", "electronics" },
        { "price", 79.99 },
        { "embedding", new BsonArray { 0.52, 0.20, 0.23 } }
    },
    new BsonDocument
    {
        { "_id", "vec-002" },
        { "name", "Bluetooth Speaker" },
        { "category", "electronics" },
        { "price", 49.99 },
        { "embedding", new BsonArray { 0.55, 0.89, 0.44 } }
    },
    new BsonDocument
    {
        { "_id", "vec-003" },
        { "name", "Notebook" },
        { "category", "office" },
        { "price", 4.99 },
        { "embedding", new BsonArray { 0.13, 0.92, 0.85 } }
    },
    new BsonDocument
    {
        { "_id", "vec-004" },
        { "name", "Gaming Laptop" },
        { "category", "electronics" },
        { "price", 1299.99 },
        { "embedding", new BsonArray { 0.91, 0.76, 0.83 } }
    }
};

collection.InsertMany(documents);
Console.WriteLine($"Inserted {documents.Length} documents.\n");

// --- Step 3: Vector similarity search ---
Console.WriteLine("Performing vector similarity search...");

// The query vector represents the item we want to find similar products for.
// In production, this would be generated by passing a search query or product description
// through the same embedding model used to create the document embeddings.
// Here [0.52, 0.28, 0.12] means: high tech affinity, low audio, low premium —
// so it should match "Wireless Headphones" (vec-001: [0.52, 0.20, 0.23]) most closely.
var queryVector = new BsonArray { 0.52, 0.28, 0.12 };

var searchPipeline = new[]
{
    new BsonDocument("$search", new BsonDocument("cosmosSearch",
        new BsonDocument
        {
            { "path", "embedding" },
            { "vector", queryVector },
            { "k", 3 }
        })),
    new BsonDocument("$project", new BsonDocument
    {
        { "name", 1 },
        { "category", 1 },
        { "price", 1 },
        { "similarityScore", new BsonDocument("$meta", "searchScore") }
    })
};

var results = collection.Aggregate<BsonDocument>(searchPipeline).ToList();

Console.WriteLine("Top 3 similar products:");
foreach (var doc in results)
{
    Console.WriteLine($"  {doc["name"],-25} | {doc["category"],-12} | ${doc["price"],-8} | score: {doc["similarityScore"]:F4}");
}

// --- Step 4: Filtered vector search ---
Console.WriteLine("\nFiltered vector search (electronics only)...");

var filteredPipeline = new[]
{
    new BsonDocument("$search", new BsonDocument("cosmosSearch",
        new BsonDocument
        {
            { "path", "embedding" },
            { "vector", queryVector },
            { "k", 3 },
            { "filter", new BsonDocument("category", new BsonDocument("$regex", new BsonRegularExpression("^electronics$", "i"))) }
        })),
    new BsonDocument("$project", new BsonDocument
    {
        { "name", 1 },
        { "category", 1 },
        { "price", 1 },
        { "similarityScore", new BsonDocument("$meta", "searchScore") }
    })
};

var filteredResults = collection.Aggregate<BsonDocument>(filteredPipeline).ToList();

Console.WriteLine("Similar electronics:");
foreach (var doc in filteredResults)
{
    Console.WriteLine($"  {doc["name"],-25} | ${doc["price"],-8} | score: {doc["similarityScore"]:F4}");
}
